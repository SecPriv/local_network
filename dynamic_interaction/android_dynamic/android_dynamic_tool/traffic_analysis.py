#!/usr/bin/env python3

import argparse
from pathlib import Path
import subprocess
import tempfile

from typing import Callable, Dict, List, Optional, Set, Union

from scapy.all import Packet, PacketList, load_layer, sniff
from scapy.layers.dns import DNSQR
from scapy.layers.tls.all import TLSAlert

from helper.helper_functions import check_path_exists

DomainSet = Set[Union[str, bytes]]

DEMO_TRACKING_DOMAINS: DomainSet = {"www.googleadservices.com", "app-measurement.com", "adtrack1.midasplayer.com",
                                    "ssl.google-analytics.com"}

TLS_ALERT_BAD_CERTIFICATE = 42
TLS_ALERT_UNSUPPORTED_CERTIFICATE = 43
TLS_ALERT_CERTIFICATE_UNKNOWN = 46
TLS_ALERT_UNKNOWN_CA = 48

CERTIFICATE_PINNING_ALERTS = [TLS_ALERT_BAD_CERTIFICATE, TLS_ALERT_CERTIFICATE_UNKNOWN, TLS_ALERT_UNKNOWN_CA]


class PcapAnalyzer:
    """PcapAnalyzer provides functionality for performing an analysis of pcap files generated by the dynamic
    app analysis for the Cross-Platform PPS project."""
    tracking_domain_list: Optional[DomainSet] = None  # The set of known tracking domains
    _temporary_directory: Path
    _source_file: Path
    _conversions: Dict[str, Path] = dict()

    @staticmethod
    def load_pcap(pcap_file: Union[Path, str], lfilter: Optional[Callable[[Packet], bool]] = None) -> PacketList:
        """Reads a pcap file using Scapy and returns a Scapy PacketList.

        Args:
            pcap_file: The pcap file to read.
            lfilter: This argument is passed to the optional lfilter argument of scapy.sniff().

        Returns:
            PacketList
        """
        if isinstance(pcap_file, Path):
            pcap_file = str(pcap_file)
        return sniff(offline=pcap_file, lfilter=lfilter)

    @staticmethod
    def tshark_conversion(input_file: Union[Path, str], output_file: Union[Path, str], pcap_filter: str) -> None:
        """Allows pre-filtering pcap files using TShark. The input file is read using TShark applying the passed
        Wireshark filter. Then the filtered data is stored in the output pcap file. If the output file exists already,
        it will be overwritten.

        Args:
            input_file: The pcap file to filter.
            output_file: The output file path.
            pcap_filter: The filter (syntax: Wireshark filter engine) to apply.
        """
        if isinstance(input_file, Path):
            input_file = str(input_file)
        if isinstance(output_file, Path):
            output_file = str(output_file)
        command_line: List[str] = [
            "tshark",
            "-Y",
            pcap_filter,
            "-r",
            input_file,
            "-w",
            output_file
        ]
        result = subprocess.run(command_line)
        if result.returncode != 0:
            raise RuntimeError(f"tshark exited with exit code {result.returncode}")

    @staticmethod
    def get_queried_dns_domains_from_capture(capture_file: Path) -> DomainSet:
        """Extracts all domain names from captured DNS requests.

        Args:
            capture_file: The input pcap file.

        Returns:
            The set of all requested domains.
        """
        packets: PacketList = PcapAnalyzer.load_pcap(capture_file)
        # noinspection PyTypeChecker
        dns_packets = packets.getlayer(DNSQR)
        domains: DomainSet = set()
        for packet in dns_packets:
            if isinstance(packet, DNSQR):
                domain = packet.qname.decode("UTF-8")
                if domain[-1:] == ".":
                    domain = domain[:-1]
                domains.add(domain)
        return domains

    @staticmethod
    def count_certificate_pinning_tls_alerts_in_capture(capture_file: Path) -> int:
        """Counts all TLS Alert messages in a pcap file indicating certificate pinning errors.
        THIS METHOD IS CURRENTLY NOT WORKING. To fix it, the private TLS key of the mitmproxy needs to be somehow
        loaded for decryption.

        Args:
            capture_file: The input pcap file.

        Returns:
            The amount of TLS Alert messages indicating certificate pinning errors.
        """
        raise NotImplementedError()
        load_layer("tls")
        packets: PacketList = PcapAnalyzer.load_pcap(capture_file, lfilter=lambda x: x.haslayer(TLSAlert))
        # noinspection PyTypeChecker
        tls_alerts = packets.getlayer(TLSAlert)
        counter = 0
        for packet in tls_alerts:
            if isinstance(packet, TLSAlert):
                if packet.descr in CERTIFICATE_PINNING_ALERTS:
                    counter += 1
        return counter

    def __init__(self, source: Union[Path, str]) -> None:
        """Initializes PcapAnalyzer objects.

        Args:
            source: The input pcap file to analyze.
        """
        self._temporary_directory = Path(tempfile.mkdtemp())
        if isinstance(source, str):
            source = Path(source)
        if not source.is_file():
            raise FileNotFoundError()
        self._source_file = source

    def get_source_file(self) -> Path:
        """Returns the source file used by this PcapAnalyzer instance.

        Returns:
            The source file path
        """
        return self._source_file

    def get_temporary_directory(self) -> Path:
        """Returns the temporary directory used by this PcapAnalyzer instance.

        Returns:
            The temporary directory
        """
        return self._temporary_directory

    def _generate_destination_path(self, name: str) -> Path:
        return self._temporary_directory / name

    def load_domain_list(self, input_file: Path):
        """Imports a list of known tracking domains into this PcapAnalyzer instance.
        The file must contain one domain per line

        Args:
            input_file: The path to the text file containing the domain list
        """
        self.tracking_domain_list = set()
        if not input_file.is_file():
            raise FileNotFoundError(str(input_file))
        with open(input_file, "r") as file:
            for line in file.readlines():
                line = line.strip()
                self.tracking_domain_list.add(line)

    def load_hosts_file(self, input_file: Path):
        """Imports a list of known tracking domains into this PcapAnalyzer instance.
        The file must be compatible to UNIX hosts files (/etc/hosts)

        Args:
            input_file: The path to the hosts file containing the domain list
        """
        self.tracking_domain_list = set()
        if not input_file.is_file():
            raise FileNotFoundError(str(input_file))
        with open(input_file, "r") as file:
            for line in file.readlines():
                line = line.strip()
                if not line.startswith(("#", ';;')) and len(line) >= 9:
                    entry = line.split()
                    if len(entry) == 2:
                        domain = entry[1]
                        self.tracking_domain_list.add(domain)

    def get_tshark_conversion(self, destination_name: str, filter_expression: str, save: bool = True) -> Path:
        """Pre-filters the source pcap file of this PcapAnalyzer instance according to passed filter using TShark.

        Args:
            destination_name: The identifier for the output (without file extension). Used for referencing too.
            filter_expression: The Wireshark filter to apply
            save: Specifies whether the output file shall be remembered by this PcapAnalyzer instance.

        Returns:
            The path to the generated output file
        """
        destination: Path = self._generate_destination_path(destination_name + ".pcap")
        PcapAnalyzer.tshark_conversion(self._source_file, destination, filter_expression)
        if save:
            self._conversions[destination_name] = destination
        return destination

    def get_queried_dns_domains(self, use_unfiltered_capture_file: bool = False) -> DomainSet:
        """Extracts all requested domain names (DNS) from the input pcap file of this instance.

        Args:
            use_unfiltered_capture_file: If True, pre-filtering using TShark will not be used.

        Returns:
            The set of all requested domains.
        """
        conversion_name = "dns"
        if use_unfiltered_capture_file:
            capture_file = self._source_file
        elif conversion_name in self._conversions:
            capture_file = self._conversions[conversion_name]
        else:
            capture_file = self.get_tshark_conversion(conversion_name, "dns.qry.name")
        return PcapAnalyzer.get_queried_dns_domains_from_capture(capture_file)

    def get_captured_tracking_domains(self, tracking_domains: Optional[DomainSet]) -> DomainSet:
        """Extracts all requested domain names (DNS) known to be tracking domains from the instance input pcap file.

        Args:
            tracking_domains: Allows using another domain list than the list imported into this PcapAnalyzer instance.

        Returns:
            The set of all requested tracking domains.
        """
        if tracking_domains is None:
            tracking_domains = self.tracking_domain_list
        queried_domains = self.get_queried_dns_domains()
        result: DomainSet = queried_domains.intersection(tracking_domains)
        return result

    def count_certificate_pinning_alerts(self, use_unfiltered_capture_file: bool = False) -> int:
        """Counts all TLS Alert messages indicating certificate pinning errors in the pcap file of this instance.
        THIS METHOD IS CURRENTLY NOT WORKING. To fix it, the private TLS key of the mitmproxy needs to be somehow
        loaded for decryption.

        Args:
            use_unfiltered_capture_file: If True, pre-filtering using TShark will not be used.

        Returns:
            The amount of captured TLS Alert messages indicating certificate pinning errors.
        """
        raise NotImplementedError()
        conversion_name = "tlsalert"
        if use_unfiltered_capture_file:
            capture_file = self._source_file
        elif conversion_name in self._conversions:
            capture_file = self._conversions[conversion_name]
        else:
            capture_file = self.get_tshark_conversion(conversion_name, "tls.alert_message")
        return PcapAnalyzer.count_certificate_pinning_tls_alerts_in_capture(capture_file)

    def print_dns_analysis(self, tracking_domains: Optional[DomainSet] = None) -> int:
        """Performs an analysis of the requested tracking domains (DNS) and prints the results.

        Args:
            tracking_domains: Allows using another domain list than the list imported into this PcapAnalyzer instance.

        Returns:
            The amount of requested tracking domains.
        """
        result = self.get_captured_tracking_domains(tracking_domains)
        print(f"Number of unique tracking domains captured: {len(result)}")
        return len(result)

    def print_certificate_pinning_analysis(self) -> int:
        """Performs an analysis of the pcap file regarding certificate pinning.
        THIS METHOD IS CURRENTLY NOT WORKING. To fix it, the private TLS key of the mitmproxy needs to be somehow
        loaded for decryption.

        Returns:
            The amount of captured TLS Alert messages indicating certificate pinning errors.
        """
        result = self.count_certificate_pinning_alerts()
        print(f"Number of captured TLS Alerts indicating a potential certificate pinning error: {result}")
        return result

    def print_complete_analysis(self) -> None:
        """Performs all implemented pcap analysis steps applying the default configuration"""
        self.print_dns_analysis()


def main():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description='Analyze a pcap capture file generated by the Dynamic Android App Analysis tool'
                    ' for Cross-Platform PPS'
    )

    parser.add_argument('input', metavar='InputFile', type=check_path_exists, help='The input file to analyze.')

    parser.add_argument('--dns-tracking-domains', '-d',
                        action='store_true',
                        help='Count queried (DNS) known tracking domain'
                        )
    domain_list_options = parser.add_mutually_exclusive_group()
    domain_list_options.add_argument('--tracking-domain-list', '-l',
                                     type=check_path_exists,
                                     help='Specify a simple domain list for --dns-tracking-domains. Expects a path to '
                                          'a file containing one domain per line.'
                                     )
    domain_list_options.add_argument('--tracking-hosts-file', '-H',
                                     type=check_path_exists,
                                     help='Specify a hosts file as domain list for --dns-tracking-domains.'
                                     )
    # parser.add_argument('--count-certificate-pinning-alerts', '-c',
    #                    action='store_true',
    #                    help='Count TLSAlert messages indicating a certificate pinning related error'
    #                    )

    args = parser.parse_args()

    analyzer = PcapAnalyzer(args.input)

    if args.dns_tracking_domains:
        if args.tracking_domain_list:
            analyzer.load_domain_list(args.tracking_domain_list)
        elif args.tracking_hosts_file:
            analyzer.load_hosts_file(args.tracking_hosts_file)
        analyzer.print_dns_analysis()


if __name__ == "__main__":
    main()
